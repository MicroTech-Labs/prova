.comment %
	(C) Copyright by MicroTech
		All rights Reserved.

Le funzioni chiamabili da C sono LABEL@::
Le funzioni chiamabili da ASM sono _LABEL::

Le variabili dichiarate (e allocate) in un .C che devono
essere visibili da ASM vanno referenziate con
LABEL@##
dove ## serve ad esplicitare ad M80 che l'etichetta e' esterna
e @ sembra essere implicitamente aggiunto alle etichette del C
Attenzione al numero di caratteri (la @ entra nel computo dei 6 caratteri)
%

;------ Faking stuff for M80 and MX ------------------------------------
module	macro		;; "module" must be lower cased
	endm

endmodule macro 	;; "endmodule" must be lower cased
	endm

extrn	macro
	endm
;-----------------------------------------------------------------------

   INCLUDE CONFIG.INC

.comment %
void oplddr(char *d, char *s, size_t n)
%

	MODULE	OPLDDR

OPLDDR@::

    ; torna se n == 0
    ld a,b
    or c
    ret z

    ; posiziona HL e DE sull'ultimo byte delle zone sorgente e destinazione rispettivamente
    add hl,bc
    dec hl
    ex de,hl
    add hl,bc
    dec hl

    ; "copia" all'indietro la zona richiesta
    lddr
    ret

    ENDMODULE

; ***

.comment %
void opldir(char *d, char *s, size_t n)
    ACT come LDIR Z80 ma con test se n == 0
%

	MODULE	OPLDIR

OPLDIR@::

    ; torna se n == 0
    ld a,b
    or c
    ret z

    ex de,hl
    ldir
    ret

    ENDMODULE

; ***

	MODULE	PRTREG

.comment %
    stampa registri Z80 passando attraverso bdos
%

bdos    equ 0F37Dh

stampaA:
        push af
        srl a
        srl a
        srl a
        srl a
        call L2_B2
        pop af
        and 00001111b
L2_B2:
        or 48
        cp 58
        call nc,L2_B3
        ld e,a
        ld c,2	;CONSOLE_OUTPUT
        jp bdos

L2_B3:
        add a,7
        ret


; ***
;   IN
;   OUT Cy = 1 tasto premuto, A = carattere
;       Cy = 0 nessun tasto premuto
RdKbd:
        ld c,0bh    ; _CONST
        call bdos
        and a
        ret z   ; se A == 0 allora Z = 1 e Cy = 0

        ld c,07h    ; _DIRIN
        call bdos
        scf
        ret


; ***
;   IN
;   OUT A = tasto premuto
WKbd:
        call RdKbd
        jr nc,WKbd
        ret

;;;; ***
;;;;   IN  A = carattere ASCII da stampare
;;;;   OUT
;;;WriteChar:
;;;        ld e,a
;;;        ld c,2	;CONSOLE_OUTPUT
;;;        jp bdos

; ***
;   IN  HL = puntatore a zstr
;   OUT
WZStr:
        ld a,(hl)
        or a
        ret z
        push hl
        ld e,a
        ld c,2	;CONSOLE_OUTPUT
        call bdos
        pop hl
        inc hl
        jr WZStr

stampaHL:
        ld a,h
        push hl
        call stampaA
        pop hl
        ld a,l
        jp stampaA    ;L2_B

prtreg@::
;
;       routine 2
;
;       IN       //
;       OUT      prints registers
;       MODIFIES Nothing
;
        push iy
        push ix
        push hl
        push de
        push bc
        push af
;
        push iy
        push ix
        push hl
        push de
        push bc
        push af

        ld hl,regStr
        call WZStr

        ; stampa i 6 registri
        ld b,6
L2_A:
        pop hl
        push bc
        call stampaHL
        ld e,' '
        ld c,2          ; CONSOLE_OUTPUT
        call bdos
        pop bc
        djnz L2_A

        ; stampa SP
        ld hl,0
        add hl,sp
        call stampaHL

        ld hl,crlfStr
        call WZStr

        call WKbd

        pop af
        pop bc
        pop de
        pop hl
        pop ix
        pop iy

        ret

regStr:
        defb ' AF   BC   DE   HL   IX   IY   SP'
        defb 13,10,0

crlfStr:
        defb 13,10,0

GetSp@::
    ld hl,0
    add hl,sp
    ret

    ENDMODULE

; ***

	MODULE	ST

STL equ     0E6H
STH equ     0E7H

.comment %
    *** System Timer routines ***
%


.comment %
    IN
    OUT
    ACT system timer reset
%
STRes@::
    out (STL),a
    ret


.comment %
    IN
    OUT HL = system timer value
%
STGet@::

    ld  c,STH

?stget:
    in  a,(c)
    dec c
    in  l,(c)
    inc c
    in  h,(c)
    cp  h
    jr  nz,?stget
    ret

;;;STGet@::
;;;
;;;    ld c,STH
;;;    ld a,i
;;;    jp po,?3
;;;
;;;; ints enabled
;;;    di
;;;?1:
;;;    in h,(c)
;;;    in a,(STL)
;;;    or a
;;;    jp z,?1
;;;
;;;	ei
;;;    ld l,a
;;;    ret
;;;
;;;; ints already off
;;;?3:
;;;    in h,(c)
;;;    in a,(STL)
;;;    or a
;;;    jp z,?3
;;;    ld l,a
;;;    ret


; ***
.comment %

    IN  A = number of system time tick to wait for
    OUT
    NB  does NOT care about interrupts
%
STLWait@::

    ld  d,a
    in  a,(STL)
    ld  e,a
?STLW1:
    in  a,(STL)
    sub e
    cp  d
    ret nc
    jr  ?STLW1


; ***
.comment %

    IN
    OUT A = l.s.b. of system timer
    NB
%
STLGet@::

    in  a,(STL)
    ret

    ENDMODULE

; ***

	MODULE	BZERO

.comment %
    *** facility to memset(addr, filler, size) ***
%

.comment %
    IN  HL = address
        DE = size
    OUT
    ACT
	USE VOID bzero(memAddr, size)
%
bzero@::

    ; se size == 0 torna senza fare niente
    ld a,d
    or e
    ret z

    ; size >= 1
    xor a
    ld (hl),a

    ; se size == 1, gia' finito
    dec de
    ld a,d
    or e
    ret z

    ; fill con zero altrimenti
    ld b,d
    ld c,e
    ld d,h
    ld e,l
    inc de
    ldir
    ret

    ENDMODULE

; ***

	MODULE	U8TOI

.comment %

    IN  U8 A = quantita' 8 bit con segno
    OUT int HL = quantita' equivalente

                oGamma = u8toi((U8) relCol);
%

U8TOI@::

    ld h,0
    ld l,a
    bit 7,a
    ret z       ; ret if A >= 0

    ; else H = 0FFh
    dec h
    ret

	ENDMODULE

; ***

	MODULE	INTLOCK

.comment %

    IN
    OUT HL = current interrupt status 
    ACT disable ints
%

INTLOCK@::

    ld a,i
    push af
    pop hl
    ret po      ; return when ints already off

    ; disable ints
    di
    ret

    ENDMODULE

; ***

	MODULE	INTUNLOCK

.comment %

    IN  int = informazione abilitazione interrupt
    OUT
%

INTUNLOCK@::

    push hl
    pop af
    ret po      ; return when ints were off during intLock

    ; enable ints
    ei
    ret

    ENDMODULE

; ***

	MODULE	SETEHR

myEHR@::

    push af

    ; if CTRL+C or CTRL+STOP pressed, avoid DOS error handling

    cp 09FH         ; .STOP
    jr z,ehr0

    cp 09EH         ; .CTRLC
    jr z,ehr0

    pop af

    ret

    ; pop return address so execution continues as usual

ehr0:

    pop af
    pop hl
    ret

.comment %

    IN
    OUT
%

setEHR@::

    ld c,063h       ; C = _DEFAB
    ex de,hl        ; DE = Address of abort exit routine 
    jp 00005h

    ENDMODULE

; ***

; Bios Kbd

	MODULE	BK

KEYBUF          EQU     0FBF0H      ; ,40
PUTPNT          EQU     0F3F8H      ; ,2
GETPNT          EQU     0F3FAH      ; ,2


; Bios Kbd FLUSH
bkFlush@::

    di
    ld hl,KEYBUF
    ld (GETPNT),hl
    ld (PUTPNT),hl
    ei
    ret

;   IN  HL = pointer to zstring
;   NB  doesn't wrap inside KEYBUF

bkAppend@::

    ; return if NULL

    ld a,h
    or l
    ret z

    ; avoid ints

    ld a,i
    push af
    jp po,app_0
    di
app_0:

    ld de,(PUTPNT)
app_2:
    ld a,(hl)
    or a
    jr z,app_3
    ld (de),a
    inc hl
    inc de
    jr app_2
app_3:
    ld (PUTPNT),de

    pop af
    jp po,app_1
    ei
app_1:

    ret

    ENDMODULE

; ***

	MODULE	DBGTEST

lab1@::

    nop
    nop
    nop
    ret

TEST0@::

    ld hl,01234h
    ld bc,05678h
    xor a

    DB 0EDh
    DB 00

    ret

    LD  HL,lab1@

    ;;; DDLUT
    LD IX,lab1@     ; DD 21 XX XX
    LD (lab1@),IX  ; DD 22 XX XX
    INC IX          ; DD 23

    ;;; CBLUT
    SET 7,H         ; CB FC
    SET 7,L         ; CB FD
    SET 7,(HL)      ; CB FE

    ;; DDCBLUT
    RLC (IX+100)    ; DD CB XX 06

    ;;; EDLUT
    SBC HL,BC       ; ED 42
    LD (lab1@),BC   ; ED 43 XX XX
    NEG             ; ED 44

    ;;; OC0LUT
    LD A,100        ; 3E XX
    CCF             ; 3F
    LD B,B          ; 40

    ;;; FDCBLUT
    SET 6,(IY+100)  ; FD CB XX F6

    ;;; FDLUT
    LD IY,lab1@     ; FD 21 XX XX
    LD (lab1@),IY   ; FD 22 XX XX
    INC IY          ; FD 23

    ret

K@::        db 0
K3@::        db 0
K4@@::        db 0
K5@@@::        db 0
K6@@@@::        db 0
K7@@@@@::        db 0

TEST1@::

    ld  hl,K@
    ld  de,K3@
    ld  bc,K4@@
    ld  ix,6
    ld  iy,7
    ld  hl,K5@@@
    ld  de,K6@@@@
    ld  af,K7@@@@@
    ld  af,(K7@@@@@)
    ld  sp,K7@@@@@
    ld  sp,(K7@@@@@)

    ret

area:  defs    16
localbuf:   defs    16

TEST2@::

    ld c,03AH

    IN B,(C)
    OUT (C),B
    SBC HL,BC
    LD (localbuf),BC
    NEG
    RETN
    IM 0
    LD I,A
    IN C,(C)
    OUT (C),C
    ADC HL,BC
    LD BC,(localbuf)

    IN D,(C)
    OUT (C),D
    SBC HL,DE
    LD (localbuf),DE
    ld iy,nexti
    push iy
    RETI
nexti:

    ld      ix,localbuf
    ld      d,(ix+5)
    ld      e,(ix+127)
    ld      h,100
    ld      (ix+5),h
    sub     (ix+5)
    ld      (ix+5),7

    push    ix
    ex      (sp),hl
    ex      (sp),ix
    pop     ix

    ld      ix,exitpoint
    jp      (ix)

TJR@::

    jr  TJR@
    jr  nz,TJR2@
    jr  z,TJR2@
    djnz TJR2@

TJR2@::

    jr  c,TJR2@
    jr  nc,TJR2@
    djnz TJR@

    ret

exitpoint:


    ld      iy,localbuf
    ld      d,(iy+5)
    ld      e,(iy+127)
    ld      h,100
    ld      (iy+5),h
    sub     (iy+5)
    ld      (iy+5),7

    push    iy
    ex      (sp),hl
    ex      (sp),iy
    pop     iy

    ld      iy,ex22
    jp      (iy)

ex22:

    ret

   ENDMODULE

    MODULE	CRC16

; https://map.grauw.nl/articles/fast_loops.php
;
;    ld b,e          ; Number of loops is in DE
;    dec de          ; Calculate DB value (destroys B, D and E)
;    inc d
;    ; B = lsb, D = msb
;Loop:
;    ; ... do something here
;    djnz Loop
;    dec d
;    jp nz,Loop




;;;CRCAIO@::
;;;; https://mdfs.net/Info/Comp/Comms/CRC16.htm
;;;; U16 crc16(U8 *p, U16 seed, size_t len)
;;;;
;;;; IN
;;;;   HL = U8 *p
;;;;   DE = U16 seed
;;;;   BC = size_t len
;;;; OUT
;;;;   A = 0 ok
;;;;   A != 0 ERROR
;;;
;;;    ld a,c
;;;    dec bc
;;;    inc b
;;;    ld c,b
;;;    ld b,a
;;;    ; B = lsb, C = msb
;;;
;;;crc0:
;;;    LD A,(HL)
;;;    XOR D             ; XOR byte into CRC top byte
;;;
;;;    SLA E
;;;    ADC A,A             ; Rotate CRC
;;;    JP NC,clear0
;;;    LD D,A              ; Put CRC high byte back into D
;;;    LD A,E
;;;    XOR 021h    ; #0x21
;;;    LD E,A              ; CRC=CRC XOR &1021, XMODEM polynomic
;;;    LD A,D
;;;    XOR 010h    ; #0x10           ; And get CRC top byte back into A
;;;clear0:
;;;
;;;    SLA E
;;;    ADC A,A             ; Rotate CRC
;;;    JP NC,clear1
;;;    LD D,A              ; Put CRC high byte back into D
;;;    LD A,E
;;;    XOR 021h    ; #0x21
;;;    LD E,A              ; CRC=CRC XOR &1021, XMODEM polynomic
;;;    LD A,D
;;;    XOR 010h    ; #0x10           ; And get CRC top byte back into A
;;;clear1:
;;;
;;;    SLA E
;;;    ADC A,A             ; Rotate CRC
;;;    JP NC,clear2
;;;    LD D,A              ; Put CRC high byte back into D
;;;    LD A,E
;;;    XOR 021h    ; #0x21
;;;    LD E,A              ; CRC=CRC XOR &1021, XMODEM polynomic
;;;    LD A,D
;;;    XOR 010h    ; #0x10           ; And get CRC top byte back into A
;;;clear2:
;;;
;;;    SLA E
;;;    ADC A,A             ; Rotate CRC
;;;    JP NC,clear3
;;;    LD D,A              ; Put CRC high byte back into D
;;;    LD A,E
;;;    XOR 021h    ; #0x21
;;;    LD E,A              ; CRC=CRC XOR &1021, XMODEM polynomic
;;;    LD A,D
;;;    XOR 010h    ; #0x10           ; And get CRC top byte back into A
;;;clear3:
;;;
;;;    SLA E
;;;    ADC A,A             ; Rotate CRC
;;;    JP NC,clear4
;;;    LD D,A              ; Put CRC high byte back into D
;;;    LD A,E
;;;    XOR 021h    ; #0x21
;;;    LD E,A              ; CRC=CRC XOR &1021, XMODEM polynomic
;;;    LD A,D
;;;    XOR 010h    ; #0x10           ; And get CRC top byte back into A
;;;clear4:
;;;
;;;    SLA E
;;;    ADC A,A             ; Rotate CRC
;;;    JP NC,clear5
;;;    LD D,A              ; Put CRC high byte back into D
;;;    LD A,E
;;;    XOR 021h    ; #0x21
;;;    LD E,A              ; CRC=CRC XOR &1021, XMODEM polynomic
;;;    LD A,D
;;;    XOR 010h    ; #0x10           ; And get CRC top byte back into A
;;;clear5:
;;;
;;;    SLA E
;;;    ADC A,A             ; Rotate CRC
;;;    JP NC,clear6
;;;    LD D,A              ; Put CRC high byte back into D
;;;    LD A,E
;;;    XOR 021h    ; #0x21
;;;    LD E,A              ; CRC=CRC XOR &1021, XMODEM polynomic
;;;    LD A,D
;;;    XOR 010h    ; #0x10           ; And get CRC top byte back into A
;;;clear6:
;;;
;;;    SLA E
;;;    ADC A,A             ; Rotate CRC
;;;    JP NC,clear7
;;;    LD D,A              ; Put CRC high byte back into D
;;;    LD A,E
;;;    XOR 021h    ; #0x21
;;;    LD E,A              ; CRC=CRC XOR &1021, XMODEM polynomic
;;;    LD A,D
;;;    XOR 010h    ; #0x10           ; And get CRC top byte back into A
;;;clear7:
;;;
;;;    LD D,A              ; Put CRC top byte back into D
;;;    INC HL
;;;
;;;    djnz crc0
;;;    dec c
;;;    jp nz,crc0
;;;
;;;    ; DE = crc16
;;;    ; HL -> m.s.b. del crc contenuto nel blocco ricevuto
;;;
;;;    ld a,(hl)
;;;    cp d
;;;    jp nz,crcko
;;;    inc hl
;;;    ld a,(hl)
;;;    cp e
;;;    jp nz,crcko
;;;
;;;; crc ok
;;;    xor a
;;;    ret
;;;
;;;crcko:
;;;    ld a,1
;;;    ret


CRC16@::
; https://mdfs.net/Info/Comp/Comms/CRC16.htm
; U16 crc16(U8 *p, U16 seed, size_t len)
;
; IN
;   HL = U8 *p
;   DE = U16 seed
;   BC = size_t len
; OUT
;   HL = U16 crc

    ld a,c
    dec bc
    inc b
    ld c,b
    ld b,a
    ; B = lsb, C = msb

crc0:
    LD A,(HL)
    XOR D             ; XOR byte into CRC top byte

    SLA E
    ADC A,A             ; Rotate CRC
    JP NC,clear0
    LD D,A              ; Put CRC high byte back into D
    LD A,E
    XOR 021h    ; #0x21
    LD E,A              ; CRC=CRC XOR &1021, XMODEM polynomic
    LD A,D
    XOR 010h    ; #0x10           ; And get CRC top byte back into A
clear0:

    SLA E
    ADC A,A             ; Rotate CRC
    JP NC,clear1
    LD D,A              ; Put CRC high byte back into D
    LD A,E
    XOR 021h    ; #0x21
    LD E,A              ; CRC=CRC XOR &1021, XMODEM polynomic
    LD A,D
    XOR 010h    ; #0x10           ; And get CRC top byte back into A
clear1:

    SLA E
    ADC A,A             ; Rotate CRC
    JP NC,clear2
    LD D,A              ; Put CRC high byte back into D
    LD A,E
    XOR 021h    ; #0x21
    LD E,A              ; CRC=CRC XOR &1021, XMODEM polynomic
    LD A,D
    XOR 010h    ; #0x10           ; And get CRC top byte back into A
clear2:

    SLA E
    ADC A,A             ; Rotate CRC
    JP NC,clear3
    LD D,A              ; Put CRC high byte back into D
    LD A,E
    XOR 021h    ; #0x21
    LD E,A              ; CRC=CRC XOR &1021, XMODEM polynomic
    LD A,D
    XOR 010h    ; #0x10           ; And get CRC top byte back into A
clear3:

    SLA E
    ADC A,A             ; Rotate CRC
    JP NC,clear4
    LD D,A              ; Put CRC high byte back into D
    LD A,E
    XOR 021h    ; #0x21
    LD E,A              ; CRC=CRC XOR &1021, XMODEM polynomic
    LD A,D
    XOR 010h    ; #0x10           ; And get CRC top byte back into A
clear4:

    SLA E
    ADC A,A             ; Rotate CRC
    JP NC,clear5
    LD D,A              ; Put CRC high byte back into D
    LD A,E
    XOR 021h    ; #0x21
    LD E,A              ; CRC=CRC XOR &1021, XMODEM polynomic
    LD A,D
    XOR 010h    ; #0x10           ; And get CRC top byte back into A
clear5:

    SLA E
    ADC A,A             ; Rotate CRC
    JP NC,clear6
    LD D,A              ; Put CRC high byte back into D
    LD A,E
    XOR 021h    ; #0x21
    LD E,A              ; CRC=CRC XOR &1021, XMODEM polynomic
    LD A,D
    XOR 010h    ; #0x10           ; And get CRC top byte back into A
clear6:

    SLA E
    ADC A,A             ; Rotate CRC
    JP NC,clear7
    LD D,A              ; Put CRC high byte back into D
    LD A,E
    XOR 021h    ; #0x21
    LD E,A              ; CRC=CRC XOR &1021, XMODEM polynomic
    LD A,D
    XOR 010h    ; #0x10           ; And get CRC top byte back into A
clear7:

    LD D,A              ; Put CRC top byte back into D
    INC HL

    djnz crc0
    dec c
    jp nz,crc0

    ex de,hl
    RET

;   IN  HL = data pointer
;   OUT HL = big endian 16 bit value @ data pointer
RDBE16@::

    ld a,(hl)
    inc hl
    ld l,(hl)
    ld h,a
    ret

   ENDMODULE


.comment %
void oplddr(char *d, char *s, size_t n)
%

	MODULE	PUTKB

PUTPNT equ 0F3F8H
GETPNT equ 0F3FAH
KEYBUF equ 0FBF0H   ; DEFS 40

PUTKB@::

    di
    ld de,KEYBUF
    ld (GETPNT),de
putkb1:
    ld a,(hl)
    or a
    jr z,putkb0
    ld (de),a
    inc hl
    inc de
    jr putkb1
putkb0:
    ld (PUTPNT),de
    ei
    ret

    ENDMODULE

.comment %
void getix()
%

	MODULE	GETIX

GETIX@::

    push ix
    pop hl
    ret

    ENDMODULE

    end

; EOF
