.comment %
	(C) Copyright by MicroTech
		All rights Reserved.

Le funzioni chiamabili da C sono LABEL@::
Le funzioni chiamabili da ASM sono _LABEL::

Le variabili dichiarate (e allocate) in un .C che devono
essere visibili da ASM vanno referenziate con
LABEL@##
dove ## serve ad esplicitare ad M80 che l'etichetta e' esterna
e @ sembra essere implicitamente aggiunto alle etichette del C
Attenzione al numero di caratteri (la @ entra nel computo dei 6 caratteri)
%

;------ Faking stuff for M80 and MX ------------------------------------
module	macro		;; "module" must be lower cased
	endm

endmodule macro 	;; "endmodule" must be lower cased
	endm

extrn	macro
	endm
;-----------------------------------------------------------------------

	MODULE	jcA

    INCLUDE INTS.INC

    INCLUDE Z-MACRO.INC

    INCLUDE JCA.INC

;save14: defs    1
;save15: defs    1
;pRx:    defs    2

    EXTERNAL intLock@
    EXTERNAL intUnlock@

; internal utilities

; ***
;   IN
;   OUT
;   MOD A, do not change HL

psgStop@::

;    ld  a,14
;    out (PSG_SEL),a
;    ld  a,(save14)
;    out (PSG_WR),a
;
;    ld  a,15
;    out (PSG_SEL),a
;    ld  a,(save15)
;    out (PSG_WR),a

    ret

; routines name glossary
; 123456
; 1 = s for system timer
;     z for z80 @ 3,5MHz
; 2 = 0 for joystick port A
;     1 for joystick port B


;   IN  HL = where to store received byte
;   OUT A = 1 if ok
;           2 if rx error
;   ADD
;   num of byte to be received
;   where to store received byte(s)
;   




 IF 1

; ***
;   IN  HL = device handle
;   OUT HL = context info

jcLock@::

    push hl
    pop ix

    ; get interrupt info in HL
    call intLock@

;;;    jp  psgStart

psgStart@::
;   IN  IX = device handle
;   OUT
;   MOD AF, do not change HL
;   ACT (NOT IMPLEMENTED save psg registers R#14 and R#15)
;       preset psg to work with selected joystick port

;    ; save R#14
;    ld  a,14
;    out (PSG_SEL),a
;    in  a,(PSG_RD)
;    ld  (save14),a

;    ; save R#15
;    ld  a,15
;    out (PSG_SEL),a
;    in  a,(PSG_RD)
;    ld  (save15),a

    ; select joystick port

    m_swToTx
    in  a,(PSG_RD)
    and 0BFH    ; &= JC_AND_MASK (~JOY_SEL_MASK)    ; selects port 0
    bit 0,(ix + port)
    jp  z,start0
    or  040H    ; |= JC_OR_MASK JOY_SEL_MASK       ; uncomment to select Joy B JOYSTICK B DEPENDENT
start0:
    out (PSG_WR),a

    ret    


; ***
;   IN  HL = context info
;   OUT

jcUnlock@::
;;;    call psgStop
    jp intUnlock@

 ELSE

; ***
;   IN  HL = device handle
;   OUT HL = context info

jcLock@::

    push hl
    pop ix

    INT_DISABLE

    ; get interrupt info in HL
;;;    call intLock@

;;;    jp  psgStart

psgStart@::
;   IN  IX = device handle
;   OUT
;   MOD AF, do not change HL
;   ACT (NOT IMPLEMENTED save psg registers R#14 and R#15)
;       preset psg to work with selected joystick port

;    ; save R#14
;    ld  a,14
;    out (PSG_SEL),a
;    in  a,(PSG_RD)
;    ld  (save14),a

;    ; save R#15
;    ld  a,15
;    out (PSG_SEL),a
;    in  a,(PSG_RD)
;    ld  (save15),a

    ; select joystick port

    m_swToTx
    in  a,(PSG_RD)
    and 0BFH    ; &= (~JOY_SEL_MASK)    ; selects port 0
    bit 0,(ix + port)
    jp  z,start0
    or  040H    ; |= JOY_SEL_MASK       ; uncomment to select Joy B JOYSTICK B DEPENDENT
start0:
    out (PSG_WR),a

    ret    


; ***
;   IN  HL = context info
;   OUT

jcUnlock@::

;;;    call psgStop

    INT_ENABLE
    ret

;;;    jp intUnlock@

 ENDIF

;swToRx@::
;   IN  IX = device
;   OUT
;   ACT psg, IX and alt. regs setup for rx
;
;    ret
    
;;;    exx
;;;    ld  c,(ix + rxDelay)
;;;    ld  d,(ix + rxDelayHalf)
;;;    exx
;;;
;;;    ld  a,14
;;;    out (PSG_SEL),a
;;;
;;;    ret

;   IN  IX = device
;   OUT
;   ACT psg setup for tx
;
;swToTx@::
;
;    ret

;;;    exx
;;;    ld  c,(ix + txDelay)
;;;    ld  h,(ix + txAndMask)
;;;    ld  l,(ix + txOrMask)
;;;    exx
;;;
;;;    ld  a,15
;;;    out (PSG_SEL),a
;;;
;;;    ret

; ***
;   IN
;   OUT
;   ACT set TX = HIGH and wait for 1 char
;   USE AF,BC

txH@::

    m_swToTx

    in  a,(PSG_RD)
    or  (ix + txOrMask)  ; prepare A with tx = 1
    out (PSG_WR),a

    ld  a,14            ; start + 8 data + stop + 4
    ld  c,(ix + txDelay)
txH0:
    DELAY_TX
    dec a
    jr nz,txH0

    exx
    
    ret

; ***
;   USE AF

capson:
	ld a,0FFH
	ld (0FCBAH),a
    m_capsLedOn
	ret

; ***
;   USE AF

capsoff:
	xor a
	ld (0FCBAH),a
    m_capsLedOff
	ret

; ***
;   IN
;   OUT
;   ACT RTS = TTL logic high (5V), deassert RTS
;   USE AF

rtsH@::

    m_swToTx
    m_rtsH

    ret
   
; ***
;   IN
;   OUT
;   ACT RTS = TTL logic low (0V), assert RTS
;   USE AF

rtsL@::

    m_swToTx
    m_rtsL

    ret

; ***
;   IN
;   OUT A = FALSE (0) when CTS not asserted
;       A =  TRUE (1) when CTS is asserted
;   USE AF
;   ACT read CTS

cts@::

    m_swToRx

    in  a,(PSG_RD)
    and (ix + ctsAndMask)

    ; A == 0, Z==1 when CTS LOW: CTS asserted -> return A = TRUE
    ld a,1
    ret z

    ; A != 0, Z==0 when CTS HIGH: CTS not asserted -> return A = FALSE
    xor a
    ret

; ***
;   IN
;   OUT A = FALSE (0) when DSR not asserted
;       A =  TRUE (1) when DSR is asserted
;   USE AF
;   ACT read DSR

dsr@::

    m_swToRx

    in  a,(PSG_RD)
    and (ix + dsrAndMask)

    ; A == 0, Z==1 when DSR LOW: DSR asserted -> return A = TRUE
    ld a,1
    ret z

    ; A != 0, Z==0 when DSR HIGH: DSR not asserted -> return A = FALSE
    xor a
    ret

; ***
;   IN
;   OUT
;   ACT DTR = TTL logic high (5V), deassert DTR
;   USE AF

dtrH@::

    m_swToTx
    m_dtrH

    ret

; ***
;   IN
;   OUT
;   ACT DTR = TTL logic low (0V), assert DTR
;   USE AF

dtrL@::

    m_swToTx
    m_dtrL

    ret

    ENDMODULE

    end

; EOF
