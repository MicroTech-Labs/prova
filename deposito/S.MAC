.comment %
	(C) Copyright by MicroTech
		All rights Reserved.

Le funzioni chiamabili da C sono LABEL@::
Le funzioni chiamabili da ASM sono _LABEL::

Le variabili dichiarate (e allocate) in un .C che devono
essere visibili da ASM vanno referenziate con
LABEL@##
dove ## serve ad esplicitare ad M80 che l'etichetta e' esterna
e @ sembra essere implicitamente aggiunto alle etichette del C
Attenzione al numero di caratteri (la @ entra nel computo dei 6 caratteri)
%

;------ Faking stuff for M80 and MX ------------------------------------
module	macro		;; "module" must be lower cased
	endm

endmodule macro 	;; "endmodule" must be lower cased
	endm

extrn	macro
	endm
;-----------------------------------------------------------------------

; ***

	MODULE	S

    INCLUDE A2A.INC


STL             equ     0E6H
STH             equ     0E7H

    ENDMODULE


s0Rx1stInactive:

    ld  c,(ix + rxTmOutL)

    ; check for start bit

    in  a,(PSG_RD)
    rrca
    jp  nc,s0RxGo

s0RxInactive:

    ; get inactivity timebase

    in  a,(STH)
    ld  b,a     ; B = timebase

s0stillInactive:

    ; check for start bit

    in  a,(PSG_RD)
    rrca
    jp  nc,s0RxGo

    ; still inactive

    in  a,(STH)
    sub b
    cp  100     ; 100 ms
    jp  c,s0stillInactive

    ; check for start bit

    in  a,(PSG_RD)
    rrca
    jp  nc,s0RxGo

    ; decrease timeout counter

    dec c
    jp  nz,s0RxInactive

    ; timeout

    ; should setup num of chars received till now

    ld  (ix + rxMissing),e
    ld  (ix + rxMissing + 1),0

    ld  a,A2_TMOUT
    ret


; ***
;   IN  HL = rx buffer
;       E = num of chars to receive
;       C = inactivity timeout in 100ms units
s0Rx@::

s0RxC:

    ; wait for RX to go to 0

s0RxS:

    in  a,(PSG_RD)
    rrca
    ;;jp  c,s0RxS
    jp  c,s0Rx1stInactive

s0RxGo:

    ; get time base for this char

    in  a,(STL)
    exx
    ld  e,a

s0Rx0:

    in  a,(STL)
    sub e
    cp  d
    jp  c,s0Rx0

    ; read bit 0

    in  a,(PSG_RD)
    rrca
    rr  b

    ; update timebase adding TB0

    ld  a,e
    add a,d
    ld  e,a

s0Rx1:

    in  a,(STL)
    sub e
    cp  c
    jp  c,s0Rx1

    ; read bit 1

    in  a,(PSG_RD)
    rrca
    rr  b

    ; update timebase

    ld  a,e
    add a,c
    ld  e,a

s0Rx2:

    in  a,(STL)
    sub e
    cp  c
    jp  c,s0Rx2

    ; read bit 2

    in  a,(PSG_RD)
    rrca
    rr  b

    ; update timebase

    ld  a,e
    add a,c
    ld  e,a

s0Rx3:

    in  a,(STL)
    sub e
    cp  c
    jp  c,s0Rx3

    ; read bit 3

    in  a,(PSG_RD)
    rrca
    rr  b

    ; update timebase

    ld  a,e
    add a,c
    ld  e,a

s0Rx4:

    in  a,(STL)
    sub e
    cp  c
    jp  c,s0Rx4

    ; read bit 4

    in  a,(PSG_RD)
    rrca
    rr  b

    ; update timebase

    ld  a,e
    add a,c
    ld  e,a

s0Rx5:

    in  a,(STL)
    sub e
    cp  c
    jp  c,s0Rx5

    ; read bit 5

    in  a,(PSG_RD)
    rrca
    rr  b

    ; update timebase

    ld  a,e
    add a,c
    ld  e,a

s0Rx6:

    in  a,(STL)
    sub e
    cp  c
    jp  c,s0Rx6

    ; read bit 6

    in  a,(PSG_RD)
    rrca
    rr  b

    ; update timebase

    ld  a,e
    add a,c
    ld  e,a

s0Rx7:

    in  a,(STL)
    sub e
    cp  c
    jp  c,s0Rx7

    ; read bit 7

    in  a,(PSG_RD)
    rrca
    rr  b

    ; update timebase

    ld  a,e
    add a,c
    ld  e,a

  ld  a,b           ; save rx char before waiting for stop bit
  exx
  ld  (hl),a
  inc hl
  exx

s0RxE:

    in  a,(STL)
    sub e
    cp  c
    jp  c,s0RxE

    ; read stop bit

;;;    in  a,(PSG_RD)
;;;    rrca                     ; Cy = 1 if ok, Cy = 0 if stop bit not found
;    ld  a,b                     ; A = rxd byte
    exx

;    ld  (hl),a
;    inc hl

    dec e
    jp  nz,s0RxC
    xor a                       ; A = OK, all expected chars arrived

;    dec de
;    ld  a,d
;    or  e
;    jp  nz,s0RxC

    ;;; xor a ;;; A already 0
    ret


; ***

;   Tx (timing with system timer)
;
;   IN  HL = buf
;       DE = buf size (must be > 0)
;

; called if Cy = 0: A.tx = 0, NB: Cy is reset
s0TxZ:
    and h
    ret

; called if Cy = 1: A.tx = 1, NB: Cy is reset
s0TxNZ:
    or  l
    ret

; IN HL = data ptr
;    DE = data len
s0Tx@::

s0TxC@::

    ld  a,(hl)
    exx
    ld  b,a

    in  a,(PSG_RD)
    and h
    ld  d,a     ; prepare D with tx = 0

    ; "no return" point
    ; E = time base

    in  a,(STL)
    ld  e,a

    ; send start

    ld  a,d
    out (PSG_WR),a

    ; prepare next bit

    rr  b
    call nc,s0TxZ           ; DO NOT CHANGE ORDER!
    call  c,s0TxNZ
    ld  d,a                 ; D is ready for transmission

s0TxS:
    in  a,(STL)
    sub e
    cp  c
    jp  c,s0TxS

    ; send bit 0

    ld  a,d
    out (PSG_WR),a

    rr  b
    call nc,s0TxZ
    call  c,s0TxNZ
    ld  d,a

    ld  a,e
    add a,c
    ld  e,a

s0Tx0:
    in  a,(STL)
    sub e
    cp  c
    jp  c,s0Tx0

    ; send bit 1

    ld  a,d
    out (PSG_WR),a

    rr  b
    call nc,s0TxZ
    call  c,s0TxNZ
    ld  d,a                 ; C is ready for transmission

    ld  a,e
    add a,c
    ld  e,a

s0Tx1:
    in  a,(STL)
    sub e
    cp  c
    jp  c,s0Tx1

    ; send bit 2

    ld  a,d
    out (PSG_WR),a

    rr  b
    call nc,s0TxZ
    call  c,s0TxNZ
    ld  d,a                 ; C is ready for transmission

    ld  a,e
    add a,c
    ld  e,a

s0Tx2:
    in  a,(STL)
    sub e
    cp  c
    jp  c,s0Tx2

    ; send bit 3

    ld  a,d
    out (PSG_WR),a

    rr  b
    call nc,s0TxZ
    call  c,s0TxNZ
    ld  d,a                 ; C is ready for transmission

    ld  a,e
    add a,c
    ld  e,a

s0Tx3:
    in  a,(STL)
    sub e
    cp  c
    jp  c,s0Tx3

    ; send bit 4

    ld  a,d
    out (PSG_WR),a

    rr  b
    call nc,s0TxZ
    call  c,s0TxNZ
    ld  d,a                 ; C is ready for transmission

    ld  a,e
    add a,c
    ld  e,a

s0Tx4:
    in  a,(STL)
    sub e
    cp  c
    jp  c,s0Tx4

    ; send bit 5

    ld  a,d
    out (PSG_WR),a

    rr  b
    call nc,s0TxZ
    call  c,s0TxNZ
    ld  d,a                 ; C is ready for transmission

    ld  a,e
    add a,c
    ld  e,a

s0Tx5:
    in  a,(STL)
    sub e
    cp  c
    jp  c,s0Tx5

    ; send bit 6

    ld  a,d
    out (PSG_WR),a

    rr  b
    call nc,s0TxZ
    call  c,s0TxNZ
    ld  d,a                 ; C is ready for transmission

    ld  a,e
    add a,c
    ld  e,a

s0Tx6:
    in  a,(STL)
    sub e
    cp  c
    jp  c,s0Tx6

    ; send bit 7

    ld  a,d
    out (PSG_WR),a

    scf                     ; prepare stop bit
    call nc,s0TxZ
    call  c,s0TxNZ
    ld  d,a

    ld  a,e
    add a,c
    ld  e,a

s0Tx7:
    in  a,(STL)
    sub e
    cp  c
    jp  c,s0Tx7

    ; send stop bit

    ld  a,d
    out (PSG_WR),a

    ; wait for stop bit to be completely "exited"
    ; (maybe a waste of cpu time)

    ld  a,e
    add a,c
    ld  e,a

s0TxE:                  
    in  a,(STL)
    sub e
    cp  c
    jp  c,s0TxE

    exx

    inc hl
    dec de
    ld  a,d
    or  e
    jp  nz,s0TxC@

    ret

    end

; EOF
